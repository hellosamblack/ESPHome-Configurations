# Define buttons for various actions
button:
  - platform: restart
    name: Restart
    icon: mdi:power-cycle

  - platform: factory_reset
    disabled_by_default: True
    name: "Factory Reset"
    id: factory_reset_all
    icon: mdi:delete

# Define a switch for factory reset, used internally
switch:
  - platform: factory_reset
    id: factory_reset_switch
    internal: true

# Enable debug logging with an update interval of 30 seconds
debug:
  update_interval: 30s
    #Break out ESP32 info into separate sensors

# Define a time platform to sync with Home Assistant
time:
  - platform: homeassistant
    id: global_time

# Define sensors for various diagnostic metrics
sensor:

  # Internal temperature of the ESP
  - platform: internal_temperature
    name: "HW: Temperature"
    id: sys_esp_temperature

  # WiFi signal strength in dB
  - platform: wifi_signal
    name: "WiFi: Signal dB"
    id: wifi_signal_db
    unit_of_measurement: "dB"
    update_interval: 60s
    entity_category: "diagnostic"
    internal: false

  # WiFi signal strength as a percentage
  - platform: copy
    source_id: wifi_signal_db
    name: "WiFi: Signal Strength"
    id: wifi_signal_strength
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    entity_category: "diagnostic"
    device_class: signal_strength

  # Uptime of the device
  - platform: uptime
    name: "Uptime"
    entity_category: "diagnostic"

  # Debug information about heap memory and loop time
  - platform: debug
    free:
      name: "HW: Heap Free"
    block:
      name: "HW: Heap Max Block"
    loop_time:
      name: "HW: Loop Time"

  # Template sensor for the last update timestamp
  - platform: template
    name: "Last Update Timestamp"
    id: last_update_timestamp
    lambda: |-
      time_t now = id(global_time).now().timestamp;
      return now;
    update_interval: never
    device_class: timestamp

# Define text sensors for various diagnostic information
text_sensor:
  - platform: git_ref
    internal: true
    id: git_ref_id
    name: "${friendly_name} Git Ref"
    long: true
    all: true
    abbrev: 16
    dirty: "-dirty"

  - platform: version
    internal: true
    id: esphome_version_id
    name: "ESPHome Version"
    hide_timestamp: true

  # ESPHome project version (detailed)
  - platform: template
    name: "SW: Version"
    id: esphome_project_version_text_detailed
    icon: "mdi:information-box"
    entity_category: "diagnostic"
    update_interval: 600s
    lambda: |-
      #include <string> // Add this line to include the string library
      return {
        std::string("FW: ") + id(esphome_version_id).state + "\n" +
        std::string("Built: ") + App.get_compilation_time() + "\n" +
        id(git_ref_id).state
      };

  # WiFi information including IP address, SSID, BSSID, MAC address, scan results, and DNS address
  - platform: wifi_info
    ip_address:
      name: "Network: IP Address"
      address_0:
        name: "Network: IP Address"
    ssid:
      name: "WiFi: SSID"
    bssid:
      name: "WiFi: BSSID"
    #This is already visible in the device info
    # mac_address:
    #  name: Network MAC
    scan_results:
      name: "WiFi: SSIDs"
    dns_address:
      name: "Network: DNS Address"

  # Debug information about the device and reset reason
  - platform: debug
    device:
      name: "ESP32 Info"
      internal: true
      on_value:
        - lambda: |-
            auto raw_value = x.c_str();
            auto parts = std::vector<std::string>();
            auto current = std::string();
            for (int i = 0; raw_value[i] != '\0'; ++i) {
              if (raw_value[i] == '|') {
                parts.push_back(current);
                current.clear();
              } else {
                current += raw_value[i];
              }
            }
            parts.push_back(current);

            if (parts.size() >= 7) {
              id(esp32_esphome_version).publish_state(parts[0].c_str());

              auto chip_parts = std::vector<std::string>();
              auto chip_current = std::string();
              for (int i = 0; i < parts[1].length(); ++i) {
                if (parts[1][i] == ' ') {
                  chip_parts.push_back(chip_current);
                  chip_current.clear();
                } else {
                  chip_current += parts[1][i];
                }
              }
              chip_parts.push_back(chip_current);

              id(esp32_chip_model).publish_state(parts[1].substr(6, parts[1].find(" Features:")-6).c_str());

              // Process Chip Features
              auto features_str = chip_parts[2].substr(9); // Skip the colon
              auto features = std::vector<std::string>();
              auto feature_current = std::string();
              for (int i = 0; i < features_str.length(); ++i) {
                if (features_str[i] == ',') {
                  features.push_back(feature_current);
                  feature_current.clear();
                } else if (features_str[i] == 'O') {
                  break; // Stop at "Other"
                } else {
                  feature_current += features_str[i];
                }
              }
              if (!feature_current.empty()) {
                  features.push_back(feature_current);
              }

              auto formatted_features = std::string();
              for (const auto& feature : features) {
                formatted_features += feature + ", ";
              }
              if (formatted_features.length() > 2) {
                formatted_features = formatted_features.substr(0, formatted_features.length() - 2); // Remove trailing comma and space
              }
              id(esp32_chip_features).publish_state(formatted_features.c_str());

              id(esp32_chip_cores).publish_state(chip_parts[3].substr(6).c_str());
              id(esp32_chip_revision).publish_state(chip_parts[4].substr(9).c_str());

              id(esp32_framework).publish_state(parts[2].substr(11).c_str());
              id(esp32_esp_idf_version).publish_state(parts[3].substr(9).c_str());
              id(esp32_efuse_mac).publish_state(parts[4].substr(11).c_str());
              id(esp32_reset_reason).publish_state(parts[5].substr(7).c_str());
              id(esp32_wakeup_reason).publish_state(parts[6].substr(8).c_str());
            }
    reset_reason:
      name: "Uptime: Reset Reason"
  - platform: template
    name: "SW: ESPHome Version"
    internal: true
    id: esp32_esphome_version
    entity_category: diagnostic
    icon: mdi:information-outline

  - platform: template
    name: "HW: Chip Model"
    id: esp32_chip_model
    entity_category: diagnostic
    icon: mdi:chip
  - platform: template
    name: "HW: Chip Features"
    id: esp32_chip_features
    entity_category: diagnostic
    icon: mdi:feature-search-outline
  - platform: template
    name: "HW: Chip Cores"
    id: esp32_chip_cores
    entity_category: diagnostic
    icon: mdi:cpu-32-bit
  - platform: template
    name: "HW: Chip Revision"
    id: esp32_chip_revision
    entity_category: diagnostic
    icon: mdi:refresh-auto
  - platform: template
    name: "SW: Framework"
    id: esp32_framework
    entity_category: diagnostic
    icon: mdi:code-braces
  - platform: template
    name: "SW: ESP-IDF Version"
    id: esp32_esp_idf_version
    entity_category: diagnostic
    icon: mdi:code-braces
  - platform: template
    internal: true
    name: "ESP32 EFuse MAC"
    id: esp32_efuse_mac
    entity_category: diagnostic
    icon: mdi:ethernet-mac
  - platform: template
    name: "Uptime: Reset Reason"
    id: esp32_reset_reason
    entity_category: diagnostic
    icon: mdi:restart
  - platform: template
    name: "Uptime: Wakeup Reason"
    id: esp32_wakeup_reason
    entity_category: diagnostic
    icon: mdi:power-sleep